from sklearn.tree import DecisionTreeClassifier
from sklearn.utils import resample
from sklearn.model_selection import train_test_split, KFold
from sklearn.metrics import precision_score, recall_score, f1_score, roc_auc_score, zero_one_loss
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler


NORMALIZACION
scaler = MinMaxScaler()
dataset = pd.read_csv('C:/Users/Jorge/PycharmProjects/PC1 IA  ARBOL DE DECISION/Cardiotocographic-Training.csv')
y = dataset.CLASE.to_numpy()
X = dataset.drop('CLASE', axis=1).to_numpy()
X = scaler.fit_transform(X)

BOOTSTRAP
def bootstrap(X, y, model, k, c, g):
    indices = np.array([i for i in range (len(X))])
    precisions = []
    recalls = []
    f1s = []
    aucs = []
    errors = []
    for i in range(k):
        train_index = resample(indices, n_samples=k, replace=True)
        test_index = np.array([j for j in indices if j not in train_index])
        
        x_train, y_train = X[train_index], y[train_index]
        x_test, y_test = X[test_index], y[test_index]
        
        model.fit(x_train, y_train)
        y_pred = model.predict(x_test)
        y_pred_auc = model.predict_proba(x_test)

        errors.append(zero_one_loss(y_test, y_pred))

        precision = precision_score(y_test, y_pred, average='micro') # micro porque toma en cuenta el desbalanceaminto de clases
        precisions.append(precision)

        recall = recall_score(y_test, y_pred, average='micro')
        recalls.append(recall)

        f1 = f1_score(y_test, y_pred, average='micro')
        f1s.append(f1)

        auc = roc_auc_score(y_test, y_pred_auc, multi_class='ovr')
        aucs.append(auc)
    return [np.mean(errors), np.var(errors), c, g, precisions, recalls, f1s, aucs, errors]
    
    
